# 环境的使用

```bash
# 操作系统
Ubuntu Server
# VimPlus插件：https://github.com/IceLeeGit/VimPlus

# 编译器gcc
# 通过程序打印宏可以得到编译器的版本
std::cout << __cplusplus << std::endl;
```



# C++ 关键字

``` C++
// alignas 指定对齐方式
// alignof 获得对齐方式
struct alignas(8) S{};                                                       
struct alignas(1) U{S s;};  
cout << alignof(U) << endl; 


// bool值一般是一个字节
// 不要对一个变量重新换指针变量类型引用：reinterpret_cast<char*>(bool obj);
// bool 最好不要作为函数的参数使用


// constexpr的使用：限定了编译器常量
// 如果表达式在编译器就能确定值，在编译器就会求出该值；
// 如果表达式不能再编译器确定值，就将表达式作为普通的表达式使用
constexpr int fact(int n){                                                   
     return n<1?1:n*fact(n-1);                                                
}  
// 由此函数，就可以方便的在编译的时候就能得到某个阶乘值


// dynamic cast 的使用，用于父子类之间
 Par* p =  new Child();                                                   
if(Child* res = dynamic_cast<Child*>(p)){                                
   res->t();                                                            
}  

// C++11 版本的enum
// bool 类型不应该出现在函数传参中
void show(bool isGood,bool isOK){                                            
    return;                                                                  
}                                                                            
                                                                              
void testShow(){                                                             
    show(true,false); // 调用时可读性不好
}
// enum class的用法
enum class Good{                                                             
    True,False                                                               
};                                                                           
                                                                             
enum class OK{                                                               
    True,False                                                               
};                                                                           
                                                                             
void show(Good,OK){                                                          
    return;                                                                  
}                                                                            
                                                                             
void testShow(){                                                             
   show(Good::True,OK::False);                                              
} 

// static_assert和assert
// static_assert可以在编译器处理，assert可以在运行时处理
// 如：变量是从cin得到,则编译器无法对变量值进行处理


// C++11 左值和右值
// 左值有名字、有类型、有值，右值没有名字，不能做取地址操作;
// 可以定义右值引用如 int&& c = 1;
// std::move 不会将一个变量中的内容移动到另一个变量中，唯一的功能是将左值转化为右值，让右值引用可以指向左值

// 不使用编译器自动生成的析构函数，自己手动声明出；
// 析构函数不要抛出异常!!! 
// C++ 默认的析构函数inline noexcept(ture)
class A {
public:
    // 强制修改noexcept为false导致未知错误、在try catch代码块中可能同时出现两个异常无法处理，以及资源无法释放的问题
    ~A() noexcept(false){ throw "123"; }
};

void testA() {
    try {
        A a;
        A b;// 此处会抛出两个异常并非只有一个throw "123"
    } catch (...) {
        cout << "find a error!" << endl;
    }
}

// 在构造函数中使用异常是一个好习惯，但C++很少使用try catch

// oo编程在网络编程领域使用不多，在游戏开发领域是个不错的选择

// 父类的析构函数应为virtual：
// 当用父类指针Base*指向子类Derived*对象实现多态时，delete 释放空间
// delete base和delete derived是有区别的
// 如果Base的析构函数是virtual,则二者相同;
// 如果Base的析构函数是非virtual，delete base只会调用父类的析构函数，可能造成内存泄漏

// 在构造函数中/析构函数中调用虚函数不具有多态性，调用本类的函数

// 容器iterator使用前置++效率更高 ++iter

// 在析构函数中加输出检查是否正常调用析构

// 在#include<assert.h>前定义宏#define  NDEBUG，可以使所有的assert语句失效，生成release版本程序
```

> TRI : technical report one

# 智能指针

```c++
// shared_ptr作为函数参数传递时最好采用const引用的形式减少引用计数，
// 智能指针存在循环引用的情况时，会发生内存泄漏
// weak_ptr的存在就是为了打破这种循环引用的局面！将其中一个智能指针设为weak_ptr类型

// 定义shared_ptr指针时，使用make_shared<T>(par)效率更高

// 使用优先级
直接定义类对象(非动态类型) >> unique_ptr >> shared_ptr
    
    
// 使用weak_ptr存储数据的性能消耗非常大，先lock再解引用获得数据耗费的性能是shared_ptr的十倍
```

# ASIO库

## 模型

### 同步编程模型:(Reactor事件驱动)

![image-20220321191838001](D:\Documents\GitHub\CPP_Learing\notes\images\image-20220321191838001.png)

> Lighthttpd,libevent,libev,poco

### 异步编程模型:(Proactor模型)

![image-20220321192054036](D:\Documents\GitHub\CPP_Learing\notes\images\image-20220321192054036.png)

> Asio,locp





# C++内存管理

## 基本概念

|                函数                 |      类别      | 能否重载 |
| :---------------------------------: | :------------: | :------: |
|             malloc/free             |       C        |    No    |
|             new/delete              | C++ expression |    No    |
|       ::operator new()/delete       |  C++ function  |   Yes    |
| allocator<T>::allocate()/deallocate |    C++ STL     |    -     |

# 面向对象编程

> Object Based----> Object Oriented

## 类的三种关系

- 复合：类中包含其他类对象
- 委托：类中包含其他类的指针
- 继承

## operator conversion function

```c++
// 定义的分数类Fraction转为double类型
class Fraction {
public:
    Fraction(int num,int den=1):m_numerator(num),m_denominator(den){}
    operator double() const{
        return static_cast<double>(m_numerator)/m_denominator;
    }

private:
    int m_numerator;
    int m_denominator;
};

int main(void) {
    Fraction f(3,5);
    std::cout << static_cast<double>(f) << std::endl;
    // 调用operator double()
    std::cout << 4+f << std::endl;
    return 0;
}
```

## explicit

```c++
// explicit主要用于修饰构造函数避免隐式转换
// explicit适用于构造函数中非默认参数的个数为一的情况，如果参数个数大于1，explicit作用失效
class Fraction {
public:
    Fraction(int num,int den=1):m_numerator(num),m_denominator(den){}
    operator double() const{
        return static_cast<double>(m_numerator)/m_denominator;
    }
    // 新增定义了operator+
	Fraction operator+(const Fraction& f){
        return Fraction(m_numerator+f.m_numerator,m_denominator+f.m_denominator);
    }
private:
    int m_numerator;
    int m_denominator;
};

int main(void) {
    // 此时f可能转为double，4可能转换为Fraction，造成了歧义，通过再构造函数前加explicit关键字避免隐士转换
    // 加完explicit，显然4无法再此转换为Fraction
   	Fraction d = f + 4;
    return 0;
}
```

## 模板特化

```c++
// 泛化和特化
// 全特化：所有的泛型类都是确定的类型
//全特化，模板类
template<> //全特化，template行中<>为空
class Test_Class<int, double>{
public:
    static bool comp(int num1, double num2)
    {
        return (num1<num2)?true:false;
    }
};
//偏特化，模板类
template<class N>  //偏特化中,template行中，剩余的泛化类型
class Test_Class<int, N>{
public:
    static bool comp(int num1, double num2)
    {
        return (num1<num2)?true:false;
    }
};
// 调用优先级：全特化>偏特化>泛化

// 针对指针的模板特化
template<typename T>
class A{
public:
    A(T a):m_a(a){}
    void operator()(T b){
        m_a+=b;
    }
    T getA() const {return m_a;}
private:
    T m_a;
};

template<typename T>
class A<T*>{
public:
    A(T* a):m_a(a){}
    void operator()(T* b){
        *m_a += *b;
    }
    T* getA() const{return m_a;}
private:
    T* m_a;
};

int main(void)
{
    A<int> a(10);
    A<int> b(20);
    a(10);
    std::cout << a.getA() << std::endl;

    int* p1 = new int(30);
    int* p2 = new int(40);
    A<int*> aip(p1);
    aip(p2);

    std::cout << *aip.getA() << std::endl;

    delete p2;
    delete p1;

    return 0;
}

```

## Object Model

> 构造函数和析构函数在继承关系下的**执行顺序**
> - 构造函数：Derived先调用Base的再执行自己的
> - 析构函数：Derived先调用自己的再调用Base的
>
> - 函数的继承：子类继承的是函数调用权，无法估量函数占用多大的空间
>
> - 多态的实现方式可以通过指针和引用实现，而**不能通过对象**实现
>
> - **const一般只用来修饰成员函数，const对象不能调用非const函数**
>
>   ```c++
>   class String{
>   public:
>       String(char* s):m_str(s){}
>       void print(){
>           std::cout << m_str << std::endl;
>       }
>                             
>   private:
>       char* m_str;
>   };
>                             
>   // 定义了一个const对象
>   const String s("123");
>   s.print();// 不能调用非const成员函数，print后要加const
>                             
>   ```
>
>   

# STL

> STL的六大部分
>
> - 容器
> - 分配器(allocator)(__gnu_cxx::pool_allocator是个好用的池分配器)
> - 算法
>   - lower_bound之前先检查`!(val<*first)`，再执行会提高效率
> - 迭代器
> - 适配器：stack、queue
>   - stack、queue默认含有一个deque成员，也可以选择list作为底层结构；
>   - stack也可以选择vector作为底层结构
>   - 不提供迭代器
> - 仿函数

## 容器

```c++
// forward list只有push_front
// deque 存储的结构是分段连续的，stack和queue均是基于deque实现
// deque每段的buffer是等长的，buffer不够需要扩容的时候，也涉及到拷贝，为了实现双端push，将数据拷贝到整个空间的中央
// 对于unordered_set/unordered_map，内部都采用hashtable实现，要想使用，必须给定一个hash函数。对于内置类型，hash<int>(),(const char*也可)即可返回一个hash code
// 当元素个数达到hash table中bucket的个数时，会将bucket个数扩大两倍并取最近的素数作为扩容后的bucket大小(GNU2.9)；之后对hashtable中所有的元素重新计算hash code，重新放入扩容后的hashtable中
```

## 迭代器

```bash
# iterator必须提供的五种associated types，rotate算法中使用了三种迭代器的相关类型
- iterator_category
	- random_access_iterator_tag
	- bidirectional_iterator_tag
	- forward_iterator_tag
	- output_iterator_tag
	- input_iterator_tag
- difference_type
- value_type # traits机制区分指针和class类型的iterator
- reference #未使用
- pointer   #未使用

# 萃取机制traits可以用来区分出class类型的iterator和pointer类型的iterator
```

![image-20220404151032342](D:\Documents\GitHub\CPP_Learing\notes\images\image-20220404151032342.png)

## 适配器

```bash
# 仿函数适配器：bind2nd/bind1st/not1
# 容器适配器: stack/queue/set/map
# 迭代器适配器：reverse_iterator/insertor
# 其他适配器: ostream_iterator/istream_iterator
```



































